## Medium tips

Taken from https://medium.com/@nickciubotariu/ace-the-coding-interview-every-time-d169ce1fd3fc

### First Round:

+ Trees (especially Binary Search Trees)
+ Big O Notation
+ Hash Tables
+ Object Oriented Design/Systems Design
+ Algorithms: Breadth First Search/Depth First Search, Binary Search, Merge Sort and Quick Sort

### Second Round:

+ Arrays
+ Recursion
+ Linked Lists
+ Stacks/Queues
+ Bit Manipulation

- - -

## Yegge tips

Taken from http://steve-yegge.blogspot.com.au/2008/03/get-that-job-at-google.html

The best tip is: go get a computer science degree. The more computer science you have, the better. You don't have to have a CS degree, but it helps. It doesn't have to be an advanced degree, but that helps too.

However, you're probably thinking of applying to Google a little sooner than 2 to 8 years from now, so here are some shorter-term tips for you.

+ Algorithm Complexity: you need to know Big-O. It's a must. If you struggle with basic big-O complexity analysis, then you are almost guaranteed not to get hired. It's, like, one chapter in the beginning of one theory of computation book, so just go read it. You can do it.

+ Sorting: know how to sort. Don't do bubble-sort. You should know the details of at least one n*log(n) sorting algorithm, preferably two (say, quicksort and merge sort). Merge sort can be highly useful in situations where quicksort is impractical, so take a look at it. For God's sake, don't try sorting a linked list during the interview.

+ Hashtables: hashtables are arguably the single most important data structure known to mankind. You absolutely have to know how they work. Again, it's like one chapter in one data structures book, so just go read about them. You should be able to implement one using only arrays in your favorite language, in about the space of one interview.

+ Trees: you should know about trees. I'm tellin' ya: this is basic stuff, and it's embarrassing to bring it up, but some of you out there don't know basic tree construction, traversal and manipulation algorithms. You should be familiar with binary trees, n-ary trees, and trie-trees at the very very least. Trees are probably the best source of practice problems for your long-term warmup exercises.

+ You should be familiar with at least one flavor of balanced binary tree, whether it's a red/black tree, a splay tree or an AVL tree. You should actually know how it's implemented.

You should know about tree traversal algorithms: BFS and DFS, and know the difference between inorder, postorder and preorder.

You might not use trees much day-to-day, but if so, it's because you're avoiding tree problems. You won't need to do that anymore once you know how they work. Study up!

## Resources:

http://ressources.unisciel.fr/algoprog/s00aaroot/aa00module1/res/%5BCormen-AL2011%5DIntroduction_To_Algorithms-A3.pdf

https://inspirit.net.in/books/placements/Cracking%20the%20Coding%20Interview.pdf

